<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Grid Breach</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0e17;
  color: #c0c8d8;
  font-family: 'Courier New', monospace;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  overflow-x: hidden;
  user-select: none;
  -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;
}
#header {
  padding: 8px;
  text-align: center;
  width: 100%;
  max-width: 500px;
}
#header h1 {
  font-size: 18px;
  color: #4af;
  letter-spacing: 3px;
  text-transform: uppercase;
}
#status-bar {
  display: flex;
  justify-content: space-between;
  padding: 4px 10px;
  font-size: 13px;
  color: #8899aa;
  width: 100%;
  max-width: 500px;
}
#status-bar .power { color: #f84; }
#status-bar .turn-info { color: #4af; }
#grid-container {
  position: relative;
  width: min(95vw, 500px);
  height: min(95vw, 500px);
}
#grid {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);
  gap: 2px;
  width: 100%;
  height: 100%;
  background: #151b2b;
  padding: 2px;
  border-radius: 4px;
}
.cell {
  position: relative;
  background: #1a2235;
  border-radius: 2px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: min(6vw, 28px);
  cursor: pointer;
  transition: background 0.15s;
}
.cell:active { transform: scale(0.95); }
.cell.highlight-move { background: #1a3a2a; }
.cell.highlight-attack { background: #3a1a1a; }
.cell.selected { background: #2a3a5a; box-shadow: inset 0 0 0 2px #4af; }
.cell.threat { background: #2a0a0a; }
.cell.enemy-dest {
  background: #2a1a0a;
  box-shadow: inset 0 0 0 1px rgba(255,100,50,0.3);
}
.cell.acted { opacity: 0.5; }
.cell .threat-arrow {
  position: absolute;
  font-size: min(3vw, 14px);
  color: #f44;
  opacity: 0.9;
  top: 1px;
  right: 2px;
  pointer-events: none;
}
.cell .hp-bar {
  position: absolute;
  bottom: 1px;
  left: 50%;
  transform: translateX(-50%);
  font-size: min(2.5vw, 10px);
  color: #4a8;
  letter-spacing: 1px;
  pointer-events: none;
}
.cell .building-hp {
  position: absolute;
  bottom: 1px;
  right: 2px;
  font-size: min(2.5vw, 10px);
  color: #fa4;
  pointer-events: none;
}
.cell .move-dot {
  position: absolute;
  top: 1px;
  left: 2px;
  font-size: min(2vw, 8px);
  color: #f84;
  opacity: 0.6;
  pointer-events: none;
}
.cell.building { background: #1a1a2a; }
.cell.mountain { background: #2a2a2a; }
#controls {
  padding: 8px;
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: center;
  max-width: 500px;
}
.btn {
  background: #1a2a4a;
  color: #4af;
  border: 1px solid #2a3a5a;
  padding: 10px 16px;
  font-family: 'Courier New', monospace;
  font-size: 13px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.15s;
}
.btn:active { background: #2a3a5a; }
.btn:disabled { opacity: 0.3; cursor: default; }
.btn.end-turn { background: #2a1a1a; border-color: #4a2a2a; color: #f84; }
#info {
  padding: 6px 12px;
  font-size: 12px;
  color: #6a7a8a;
  text-align: center;
  max-width: 500px;
  min-height: 32px;
}
#help-bar {
  padding: 4px 12px;
  font-size: 11px;
  color: #445566;
  text-align: center;
  max-width: 500px;
}
#game-over {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.85);
  z-index: 100;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
#game-over.show { display: flex; }
#game-over h2 { font-size: 28px; margin-bottom: 10px; }
#game-over p { color: #8899aa; margin-bottom: 20px; font-size: 14px; }
#game-over .btn { font-size: 16px; padding: 12px 24px; }
.win h2 { color: #4af; }
.lose h2 { color: #f44; }

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-3px); }
  75% { transform: translateX(3px); }
}
.shake { animation: shake 0.3s; }

@keyframes flash-red {
  0% { background: #5a1a1a; }
  100% { background: #1a2235; }
}
.flash { animation: flash-red 0.4s; }
</style>
</head>
<body>

<div id="header">
  <h1>âš¡ Grid Breach âš¡</h1>
</div>

<div id="status-bar">
  <span>Wave <span id="wave">1</span>/5</span>
  <span class="power">Grid <span id="grid-power">â– â– â– â– â– â– </span></span>
  <span class="turn-info">Turn <span id="turn">1</span></span>
</div>

<div id="grid-container">
  <div id="grid"></div>
</div>

<div id="info">Tap a mech to select. Green = move. Red = attack.</div>

<div id="controls">
  <button class="btn" id="btn-undo" disabled onclick="undoMove()">â†© Undo</button>
  <button class="btn" id="btn-skip" onclick="skipMech()" style="display:none">Skip â–¶</button>
  <button class="btn end-turn" id="btn-end" onclick="endTurn()">End Turn âš”</button>
  <button class="btn" id="btn-reset" onclick="resetMoves()">Reset</button>
</div>

<div id="help-bar">Push enemies into each other, off edges, or away from buildings</div>

<div id="game-over">
  <h2 id="go-title"></h2>
  <p id="go-text"></p>
  <button class="btn" onclick="initGame()">Play Again</button>
</div>

<script>
// === GAME STATE ===
const W = 8, H = 8;
let grid, mechs, enemies, buildings, mountains;
let selectedMech = null;
let turn = 1, wave = 1, gridPower = 6, maxPower = 6;
let phase = 'player';
let moveHistory = [];

const MECH_TYPES = [
  { id: 'tank', emoji: 'ðŸ¤–', name: 'Titan', hp: 3, maxHp: 3, atk: 2, range: 1, move: 3, ability: 'punch', desc: 'Melee: hits + pushes 1 tile' },
  { id: 'artillery', emoji: 'ðŸ”§', name: 'Arc', hp: 2, maxHp: 2, atk: 2, range: 3, move: 2, ability: 'shell', desc: 'Range 2-3: lobs shell, pushes adjacent' },
  { id: 'dash', emoji: 'âš¡', name: 'Bolt', hp: 2, maxHp: 2, atk: 1, range: 0, move: 4, ability: 'dash', desc: 'Dash: charges in line, pushes target' },
];

const ENEMY_TYPES = {
  bug:    { emoji: 'ðŸ”´', name: 'Bug', hp: 1, atk: 1, move: 2 },
  beetle: { emoji: 'ðŸŸ¤', name: 'Beetle', hp: 2, atk: 2, move: 1 },
  wasp:   { emoji: 'ðŸŸ¡', name: 'Wasp', hp: 1, atk: 1, move: 3 },
};

// === INIT ===
function initGame() {
  document.getElementById('game-over').className = '';
  turn = 1; wave = 1; gridPower = maxPower;
  moveHistory = [];
  phase = 'player';
  selectedMech = null;

  grid = Array.from({length: H}, () => Array(W).fill(null));
  mechs = [];
  enemies = [];
  buildings = [];
  mountains = [];

  // Mountains
  [[2,2],[5,5],[2,5],[5,2]].forEach(([r,c]) => {
    mountains.push({r,c});
    grid[r][c] = {type:'mountain'};
  });

  // Buildings (grid power sources)
  [[0,3],[0,4],[1,6],[3,0],[4,7],[6,1],[7,3],[7,4]].forEach(([r,c]) => {
    const b = {r, c, hp: 1};
    buildings.push(b);
    grid[r][c] = {type:'building', ref: b};
  });

  // Mechs
  [[6,2],[6,4],[6,6]].forEach(([pos, i]) => {});
  MECH_TYPES.forEach((mt, i) => {
    const positions = [[6,2],[6,4],[6,6]];
    const [r,c] = positions[i];
    const m = {...mt, r, c, moved: false, acted: false};
    mechs.push(m);
    grid[r][c] = {type:'mech', ref: m};
  });

  spawnEnemies();
  render();
  updateUI();
}

function spawnEnemies() {
  const count = Math.min(2 + wave, 6);
  const types = wave <= 2 ? ['bug'] : wave <= 4 ? ['bug','beetle'] : ['bug','beetle','wasp'];
  let spawned = 0, attempts = 0;
  while (spawned < count && attempts < 50) {
    attempts++;
    const r = Math.random() < 0.5 ? 0 : 1;
    const c = Math.floor(Math.random() * W);
    if (grid[r][c]) continue;
    const tname = types[Math.floor(Math.random() * types.length)];
    const et = ENEMY_TYPES[tname];
    const e = {...et, r, c, typeName: tname, intent: null, targetR: null, targetC: null, attackR: null, attackC: null};
    enemies.push(e);
    grid[r][c] = {type:'enemy', ref: e};
    spawned++;
  }
  assignIntents();
}

function assignIntents() {
  enemies.forEach(e => {
    if (e.hp <= 0) return;
    e.intent = 'idle';
    e.targetR = e.r;
    e.targetC = e.c;
    e.attackR = null;
    e.attackC = null;

    // Find closest target (prefer mechs, then buildings)
    let best = null, bestDist = 999;
    mechs.forEach(m => {
      if (m.hp <= 0) return;
      const d = Math.abs(m.r - e.r) + Math.abs(m.c - e.c);
      if (d < bestDist) { bestDist = d; best = {r: m.r, c: m.c}; }
    });
    buildings.forEach(b => {
      if (b.hp <= 0) return;
      const d = Math.abs(b.r - e.r) + Math.abs(b.c - e.c);
      if (d < bestDist - 1) { bestDist = d; best = {r: b.r, c: b.c}; }
    });

    if (!best) return;

    // Simulate movement toward target
    let dr = Math.sign(best.r - e.r);
    let dc = Math.sign(best.c - e.c);
    let moveR = e.r, moveC = e.c;
    
    for (let step = 0; step < e.move; step++) {
      // Try diagonal first, then cardinal
      let moved = false;
      const tries = [];
      if (dr !== 0 && dc !== 0) tries.push([dr, dc], [dr, 0], [0, dc]);
      else if (dr !== 0) tries.push([dr, 0], [dr, 1], [dr, -1]);
      else tries.push([0, dc], [1, dc], [-1, dc]);
      
      for (const [tr, tc] of tries) {
        const nr = moveR + tr, nc = moveC + tc;
        if (nr < 0 || nr >= H || nc < 0 || nc >= W) continue;
        if (grid[nr][nc] && !(nr === e.r && nc === e.c)) continue; // can't walk through stuff
        // Don't walk into other enemies' target positions
        moveR = nr; moveC = nc;
        moved = true;
        break;
      }
      if (!moved) break;
      
      // Recalculate direction from new pos
      dr = Math.sign(best.r - moveR);
      dc = Math.sign(best.c - moveC);
      if (dr === 0 && dc === 0) break; // arrived
    }

    e.intent = 'move';
    e.targetR = moveR;
    e.targetC = moveC;

    // Check if adjacent to any target from destination
    const adj = [[0,1],[0,-1],[1,0],[-1,0]];
    for (const [ar, ac] of adj) {
      const tr = moveR + ar, tc = moveC + ac;
      if (tr < 0 || tr >= H || tc < 0 || tc >= W) continue;
      const cell = grid[tr][tc];
      if (cell && (cell.type === 'mech' || cell.type === 'building')) {
        e.intent = 'attack';
        e.attackR = tr;
        e.attackC = tc;
        break;
      }
    }
  });
}

// === RENDERING ===
function render() {
  const gridEl = document.getElementById('grid');
  gridEl.innerHTML = '';

  // Build sets for quick lookup
  const threatCells = new Set();
  const enemyDests = new Set();
  enemies.forEach(e => {
    if (e.hp <= 0) return;
    if (e.intent === 'attack' && e.attackR !== null) threatCells.add(`${e.attackR},${e.attackC}`);
    if (e.targetR !== null && (e.targetR !== e.r || e.targetC !== e.c)) {
      enemyDests.add(`${e.targetR},${e.targetC}`);
    }
  });

  for (let r = 0; r < H; r++) {
    for (let c = 0; c < W; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      const key = `${r},${c}`;
      const g = grid[r][c];

      // Terrain / entities
      if (g) {
        if (g.type === 'mountain') {
          cell.classList.add('mountain');
          cell.textContent = 'â›°ï¸';
        } else if (g.type === 'building') {
          cell.classList.add('building');
          cell.textContent = g.ref.hp > 0 ? 'ðŸ¢' : 'ðŸ”¥';
          if (g.ref.hp > 0) {
            const hp = document.createElement('span');
            hp.className = 'building-hp';
            hp.textContent = 'â™¥';
            cell.appendChild(hp);
          }
        } else if (g.type === 'mech') {
          cell.textContent = g.ref.emoji;
          const hp = document.createElement('span');
          hp.className = 'hp-bar';
          hp.textContent = 'â—'.repeat(Math.max(0,g.ref.hp)) + 'â—‹'.repeat(Math.max(0,g.ref.maxHp - g.ref.hp));
          cell.appendChild(hp);
          // Dim if already acted
          if (g.ref.acted) cell.classList.add('acted');
        } else if (g.type === 'enemy') {
          cell.textContent = g.ref.emoji;
          const hp = document.createElement('span');
          hp.className = 'hp-bar';
          hp.textContent = 'â—'.repeat(Math.max(0,g.ref.hp));
          cell.appendChild(hp);
        }
      }

      // Enemy destination markers (where they'll move)
      if (enemyDests.has(key) && (!g || g.type === 'enemy')) {
        const dot = document.createElement('span');
        dot.className = 'move-dot';
        dot.textContent = 'â—†';
        cell.appendChild(dot);
        if (!g) cell.classList.add('enemy-dest');
      }

      // Threat indicators (where they'll attack)
      if (threatCells.has(key)) {
        cell.classList.add('threat');
        // Find which enemy is threatening this cell to show arrow
        enemies.forEach(e => {
          if (e.hp <= 0 || e.intent !== 'attack') return;
          if (e.attackR !== r || e.attackC !== c) return;
          const fr = e.targetR ?? e.r, fc = e.targetC ?? e.c;
          const dr = r - fr, dc = c - fc;
          const arrow = document.createElement('span');
          arrow.className = 'threat-arrow';
          if (dr === -1 && dc === 0) arrow.textContent = 'â†“';
          else if (dr === 1 && dc === 0) arrow.textContent = 'â†‘';
          else if (dc === -1 && dr === 0) arrow.textContent = 'â†’';
          else if (dc === 1 && dr === 0) arrow.textContent = 'â†';
          else arrow.textContent = 'âœ•';
          cell.appendChild(arrow);
        });
      }

      // Selected mech highlights
      if (selectedMech && phase === 'player') {
        const m = selectedMech;
        if (m.r === r && m.c === c) {
          cell.classList.add('selected');
        } else if (!m.acted) {
          // Can attack from current position (no move needed)
          if (!m.moved && isValidAttack(m, r, c)) {
            cell.classList.add('highlight-attack');
          }
          // Can move here
          if (!m.moved && isValidMove(m, r, c)) {
            cell.classList.add('highlight-move');
          }
          // Already moved, show attack options
          if (m.moved && !m.acted && isValidAttack(m, r, c)) {
            cell.classList.add('highlight-attack');
          }
        }
      }

      cell.addEventListener('click', () => cellClick(r, c));
      gridEl.appendChild(cell);
    }
  }

  // Show/hide skip button
  const skipBtn = document.getElementById('btn-skip');
  if (selectedMech && !selectedMech.acted) {
    skipBtn.style.display = '';
    skipBtn.textContent = selectedMech.moved ? 'Skip Atk â–¶' : 'Skip â–¶';
  } else {
    skipBtn.style.display = 'none';
  }
}

function updateUI() {
  document.getElementById('wave').textContent = wave;
  document.getElementById('turn').textContent = turn;
  const pw = document.getElementById('grid-power');
  const gp = Math.max(0, gridPower);
  pw.textContent = 'â– '.repeat(gp) + 'â–¡'.repeat(Math.max(0, maxPower - gp));
  if (gp <= 2) pw.style.color = '#f44';
  else if (gp <= 4) pw.style.color = '#fa4';
  else pw.style.color = '#f84';
  document.getElementById('btn-undo').disabled = moveHistory.length === 0;
}

// === MOVEMENT ===
function dist(r1,c1,r2,c2) { return Math.abs(r1-r2) + Math.abs(c1-c2); }

function isValidMove(mech, r, c) {
  if (r === mech.r && c === mech.c) return false;
  if (r < 0 || r >= H || c < 0 || c >= W) return false;
  if (grid[r][c]) return false;
  if (dist(mech.r, mech.c, r, c) > mech.move) return false;
  return hasPath(mech.r, mech.c, r, c, mech.move);
}

function hasPath(sr, sc, er, ec, maxDist) {
  const visited = new Set([`${sr},${sc}`]);
  const queue = [[sr, sc, 0]];
  while (queue.length) {
    const [r, c, d] = queue.shift();
    if (r === er && c === ec) return true;
    if (d >= maxDist) continue;
    for (const [dr, dc] of [[0,1],[0,-1],[1,0],[-1,0]]) {
      const nr = r+dr, nc = c+dc;
      if (nr<0||nr>=H||nc<0||nc>=W) continue;
      const key = `${nr},${nc}`;
      if (visited.has(key)) continue;
      if (nr === er && nc === ec && !grid[nr][nc]) { return true; }
      if (grid[nr][nc]) continue; // can't walk through
      visited.add(key);
      queue.push([nr, nc, d+1]);
    }
  }
  return false;
}

function isValidAttack(mech, r, c) {
  const cell = grid[r][c];
  if (!cell || cell.type !== 'enemy') return false;

  if (mech.ability === 'punch') {
    return dist(mech.r, mech.c, r, c) === 1;
  }
  if (mech.ability === 'shell') {
    const d = dist(mech.r, mech.c, r, c);
    return d >= 2 && d <= mech.range;
  }
  if (mech.ability === 'dash') {
    if (mech.r !== r && mech.c !== c) return false;
    // Must have clear line to adjacent tile
    const dr = Math.sign(r - mech.r), dc = Math.sign(c - mech.c);
    let cr = mech.r + dr, cc = mech.c + dc;
    while (cr !== r || cc !== c) {
      if (grid[cr][cc]) return false; // blocked
      cr += dr; cc += dc;
    }
    return true;
  }
  return false;
}

// === PLAYER ACTIONS ===
function cellClick(r, c) {
  if (phase !== 'player') return;
  const cell = grid[r][c];

  // Click on own mech: select/deselect
  if (cell && cell.type === 'mech' && cell.ref.hp > 0) {
    const m = cell.ref;
    if (selectedMech === m) {
      selectedMech = null;
      setInfo('');
    } else {
      selectedMech = m;
      if (m.acted) {
        setInfo(`${m.name} already acted this turn`);
      } else {
        setInfo(`${m.name}: ${m.desc}`);
      }
    }
    render();
    return;
  }

  // Click empty or enemy with no mech selected
  if (!selectedMech) {
    if (cell && cell.type === 'enemy') {
      setInfo(`${cell.ref.name} â€” HP:${cell.ref.hp} ATK:${cell.ref.atk} â€” ${cell.ref.intent === 'attack' ? 'âš  attacking!' : 'moving'}`);
    } else {
      setInfo('');
    }
    return;
  }

  const m = selectedMech;
  if (m.acted) { selectedMech = null; render(); return; }

  // ATTACK from current position (no move needed)
  if (!m.moved && cell && cell.type === 'enemy' && isValidAttack(m, r, c)) {
    if (m.ability === 'dash') {
      // Dash moves + attacks in one action
      const dr = Math.sign(r - m.r), dc = Math.sign(c - m.c);
      const adjR = r - dr, adjC = c - dc;
      if (adjR >= 0 && adjR < H && adjC >= 0 && adjC < W) {
        moveHistory.push({ mechId: m.id, fromR: m.r, fromC: m.c, type: 'dash-attack' });
        grid[m.r][m.c] = null;
        m.r = adjR; m.c = adjC;
        grid[adjR][adjC] = {type:'mech', ref: m};
      }
    } else {
      moveHistory.push({ mechId: m.id, fromR: m.r, fromC: m.c, type: 'attack-in-place' });
    }
    performAttack(m, cell.ref, r, c);
    m.moved = true;
    m.acted = true;
    selectedMech = null;
    assignIntents();
    render();
    updateUI();
    return;
  }

  // MOVE
  if (!m.moved && isValidMove(m, r, c)) {
    moveHistory.push({ mechId: m.id, fromR: m.r, fromC: m.c, type: 'move' });
    grid[m.r][m.c] = null;
    m.r = r; m.c = c;
    grid[r][c] = {type:'mech', ref: m};
    m.moved = true;
    assignIntents();
    setInfo(`${m.name} moved. Tap enemy to attack, or Skip.`);
    render();
    updateUI();
    return;
  }

  // ATTACK after move
  if (m.moved && !m.acted && cell && cell.type === 'enemy' && isValidAttack(m, r, c)) {
    performAttack(m, cell.ref, r, c);
    m.acted = true;
    selectedMech = null;
    assignIntents();
    render();
    updateUI();
    return;
  }

  // Click on empty space = deselect
  if (!cell || cell.type === 'building' || cell.type === 'mountain') {
    selectedMech = null;
    setInfo('');
    render();
  }
}

function skipMech() {
  if (!selectedMech) return;
  selectedMech.moved = true;
  selectedMech.acted = true;
  selectedMech = null;
  setInfo('');
  render();
  updateUI();
}

function performAttack(mech, enemy, er, ec) {
  enemy.hp -= mech.atk;

  // Push mechanic
  if (mech.ability === 'punch' || mech.ability === 'dash') {
    const dr = Math.sign(er - mech.r);
    const dc = Math.sign(ec - mech.c);
    pushEntity(enemy, er, ec, dr, dc);
  }
  if (mech.ability === 'shell') {
    // Push all adjacent to impact point
    [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr,dc]) => {
      const ar = er+dr, ac = ec+dc;
      if (ar<0||ar>=H||ac<0||ac>=W) return;
      const adj = grid[ar][ac];
      if (adj && adj.type === 'enemy' && adj.ref !== enemy) {
        pushEntity(adj.ref, ar, ac, dr, dc);
      }
    });
  }

  if (enemy.hp <= 0) {
    // Remove from grid
    if (grid[er]?.[ec]?.ref === enemy) grid[er][ec] = null;
    if (grid[enemy.r]?.[enemy.c]?.ref === enemy) grid[enemy.r][enemy.c] = null;
    const idx = enemies.indexOf(enemy);
    if (idx >= 0) enemies.splice(idx, 1);
    setInfo(`ðŸ’¥ ${enemy.name} destroyed!`);
  } else {
    setInfo(`${enemy.name} hit! HP: ${enemy.hp}`);
  }
}

function pushEntity(entity, fromR, fromC, dr, dc) {
  if (dr === 0 && dc === 0) return;
  const nr = fromR + dr, nc = fromC + dc;

  // Off edge
  if (nr < 0 || nr >= H || nc < 0 || nc >= W) {
    entity.hp -= 1;
    if (entity.hp <= 0) {
      if (grid[fromR][fromC]?.ref === entity) grid[fromR][fromC] = null;
      const idx = enemies.indexOf(entity);
      if (idx >= 0) enemies.splice(idx, 1);
    }
    return;
  }

  const target = grid[nr][nc];
  if (target) {
    // Collision â€” both take 1 damage
    entity.hp -= 1;
    if (target.type === 'enemy') {
      target.ref.hp -= 1;
      if (target.ref.hp <= 0) {
        const idx = enemies.indexOf(target.ref);
        if (idx >= 0) enemies.splice(idx, 1);
        grid[nr][nc] = null;
        // Push into the now-empty space
        if (entity.hp > 0) {
          if (grid[fromR][fromC]?.ref === entity) grid[fromR][fromC] = null;
          entity.r = nr; entity.c = nc;
          grid[nr][nc] = {type:'enemy', ref: entity};
        } else {
          if (grid[fromR][fromC]?.ref === entity) grid[fromR][fromC] = null;
          const idx2 = enemies.indexOf(entity);
          if (idx2 >= 0) enemies.splice(idx2, 1);
        }
        return;
      }
    }
    if (target.type === 'building') {
      target.ref.hp -= 1;
      if (target.ref.hp <= 0) gridPower--;
    }
    if (target.type === 'mech') {
      target.ref.hp -= 1;
    }
    // Entity stays in place (blocked)
    if (entity.hp <= 0) {
      if (grid[fromR][fromC]?.ref === entity) grid[fromR][fromC] = null;
      const idx = enemies.indexOf(entity);
      if (idx >= 0) enemies.splice(idx, 1);
    }
    return;
  }

  // Push to empty space
  if (grid[fromR][fromC]?.ref === entity) grid[fromR][fromC] = null;
  entity.r = nr; entity.c = nc;
  grid[nr][nc] = {type:'enemy', ref: entity};
}

function undoMove() {
  if (moveHistory.length === 0) return;
  const last = moveHistory.pop();
  const m = mechs.find(x => x.id === last.mechId);
  if (!m) return;

  // Can only undo moves, not attacks
  if (last.type === 'move') {
    grid[m.r][m.c] = null;
    m.r = last.fromR; m.c = last.fromC;
    grid[m.r][m.c] = {type:'mech', ref: m};
    m.moved = false; m.acted = false;
    selectedMech = null;
    assignIntents();
  }
  render();
  updateUI();
}

function resetMoves() {
  while (moveHistory.length) undoMove();
}

// === ENEMY TURN ===
function endTurn() {
  if (phase !== 'player') return;
  phase = 'enemy';
  selectedMech = null;
  moveHistory = [];
  setInfo('âš” Enemies acting...');
  render();

  setTimeout(() => {
    executeEnemyTurn();
    cleanupDead();

    if (checkGameOver()) return;

    if (enemies.length === 0) {
      wave++;
      if (wave > 5) { gameOver(true); return; }
      setInfo(`âš  Wave ${wave} incoming!`);
      setTimeout(() => {
        spawnEnemies();
        startNewTurn();
      }, 800);
    } else {
      assignIntents();
      startNewTurn();
    }
  }, 600);
}

function startNewTurn() {
  turn++;
  phase = 'player';
  mechs.forEach(m => { m.moved = false; m.acted = false; });
  moveHistory = [];
  setInfo('Your turn. Tap a mech.');
  render();
  updateUI();
}

function executeEnemyTurn() {
  // First: all enemies move
  enemies.forEach(e => {
    if (e.hp <= 0) return;
    if (e.targetR !== null && (e.targetR !== e.r || e.targetC !== e.c)) {
      const dest = grid[e.targetR][e.targetC];
      if (!dest) {
        if (grid[e.r][e.c]?.ref === e) grid[e.r][e.c] = null;
        e.r = e.targetR; e.c = e.targetC;
        grid[e.r][e.c] = {type:'enemy', ref: e};
      }
    }
  });

  // Then: all enemies attack
  enemies.forEach(e => {
    if (e.hp <= 0 || e.intent !== 'attack') return;
    const tr = e.attackR, tc = e.attackC;
    if (tr === null || tc === null) return;
    const target = grid[tr]?.[tc];
    if (!target) return;

    if (target.type === 'mech') {
      target.ref.hp -= e.atk;
      setInfo(`${target.ref.name} hit by ${e.name}! HP: ${target.ref.hp}`);
    } else if (target.type === 'building') {
      target.ref.hp -= e.atk;
      if (target.ref.hp <= 0) {
        gridPower--;
        setInfo(`ðŸ¢ Building destroyed! Grid: ${gridPower}`);
      }
    }
  });
}

function cleanupDead() {
  enemies = enemies.filter(e => {
    if (e.hp <= 0) {
      if (grid[e.r]?.[e.c]?.ref === e) grid[e.r][e.c] = null;
      return false;
    }
    return true;
  });
  mechs.forEach(m => {
    if (m.hp <= 0 && grid[m.r]?.[m.c]?.ref === m) {
      grid[m.r][m.c] = null;
    }
  });
  updateUI();
  render();
}

function checkGameOver() {
  if (gridPower <= 0) { gameOver(false); return true; }
  const alive = mechs.filter(m => m.hp > 0);
  if (alive.length === 0) { gameOver(false); return true; }
  return false;
}

function gameOver(win) {
  const el = document.getElementById('game-over');
  el.className = 'show ' + (win ? 'win' : 'lose');
  document.getElementById('go-title').textContent = win ? 'âš¡ VICTORY âš¡' : 'ðŸ’¥ GRID LOST ðŸ’¥';
  document.getElementById('go-text').textContent = win
    ? `Grid defended in ${turn} turns! Wave ${wave}/5 complete.`
    : `Grid power depleted. Wave ${wave}, Turn ${turn}.`;
}

function setInfo(text) {
  document.getElementById('info').textContent = text;
}

// === START ===
initGame();
</script>
</body>
</html>
